#include <malloc.h>#include "../include/CCmdExec.h"#include <stdio.h>#ifdef _DEBUG#undef THIS_FILEstatic char THIS_FILE[]=__FILE__;#define new DEBUG_NEW#endif#define BUFSIZE 4096//////////////////////////////////////////////////////////////////////// Construction/Destruction//////////////////////////////////////////////////////////////////////CCmdExec::CCmdExec(){	m_hProcess = NULL;}CCmdExec::CCmdExec(char *cmd){	strncpy(m_strCommand,cmd,255);	m_hProcess = NULL;}CCmdExec::~CCmdExec(){}BOOL CCmdExec::Execute(FILE *pFile){	BOOL bExec = false;	try	{        SECURITY_ATTRIBUTES saAttr;        //        // Set the bInheritHandle flag so pipe handles are inherited.        //        saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);        saAttr.bInheritHandle = TRUE;        saAttr.lpSecurityDescriptor = NULL;        //        // The steps for redirecting child's STDOUT:        //     2.  Create anonymous pipe to be STDOUT for child.        //     3.  Set STDOUT of parent to be write handle of pipe, so        //         it is inherited by child.        //        //        // Create a pipe for the child's STDOUT.        //        if (!CreatePipe (&m_hChildStdoutRd, &m_hChildStdoutWr, &saAttr, 0))        {			return false;        }        //        // Now create the child process to execute the command        //        InvokeImage (m_strCommand);        //        //  Read from pipe that is the standard output for child process.        //        ReadFromChild(pFile);		bExec = true;    }    catch(...)    {    }	return bExec;}BOOL CCmdExec::Execute(){	HANDLE hProcess = InvokeImage (m_strCommand);	return (hProcess != NULL);}HANDLE CCmdExec::InvokeImage    (char*  pImageName){    PROCESS_INFORMATION ProcInfo;    char     ErrorBuffer[255];    STARTUPINFO StartInfo = {sizeof(StartInfo)};    BOOL        InheritHandles = FALSE;    int         CreateFlags = 0;    //    //    If we have requested that the window should be hidden then set up the STARTUPINFO    //    StartInfo.dwFlags = STARTF_USESTDHANDLES|STARTF_USESHOWWINDOW;    StartInfo.hStdOutput = m_hChildStdoutWr;    StartInfo.hStdError = m_hChildStdoutWr;    StartInfo.wShowWindow = SW_HIDE;    InheritHandles = TRUE;    CreateFlags = CREATE_NEW_CONSOLE;    // Copy the command line, because CreateProcess may modify it directly!    char* zCmdLine = (char*)_alloca(lstrlen(pImageName) + 1);    lstrcpy(zCmdLine, pImageName);    //    //    Create a process to execute the specified image.    //    if (!CreateProcess (NULL                        ,zCmdLine                        // Command Line                        ,NULL                            // Process Security attributes                        ,NULL                            // Primary thread security attributes                        ,InheritHandles                  // Handles are {NOT} inherited                        ,CreateFlags                     // Creation flags                        ,NULL                            // Use Parents environment                        ,NULL                            // Use Parents current directory                        ,&StartInfo                      // STARTUPINFO pointer                        ,&ProcInfo))                     // Receives Process Information    {		return NULL;    }	m_hProcess = ProcInfo.hProcess;    CloseHandle(ProcInfo.hThread);    return ProcInfo.hProcess;}void    CCmdExec::ReadFromChild  (FILE *pFile){    char *s;    DWORD dwRead;    CHAR chBuf[BUFSIZE];    //    // Close the write end of the pipe before reading from the    // read end of the pipe.    //    if (!CloseHandle(m_hChildStdoutWr))    {    }    //    // Read output from child, and write it to the output window edit box.    //   // strOutputText.Empty();        for (;;)    {        if ((!ReadFile(m_hChildStdoutRd, chBuf, BUFSIZE, &dwRead, NULL)) || (dwRead == 0)) break;        chBuf[dwRead] = '\0';        fwrite(chBuf,sizeof(char),strlen(chBuf),pFile);        //strOutputText += chBuf;    }}BOOL CCmdExec::KillProcess(){	if (m_hProcess != NULL)	{		return TerminateProcess(m_hProcess, 0);	}	return true;}BOOL CCmdExec::IsActive(){	if (!m_hProcess)		return false;	DWORD dwStatus;	if(GetExitCodeProcess(m_hProcess, &dwStatus))	{		if (dwStatus == STILL_ACTIVE)			return true;	}	return false;}